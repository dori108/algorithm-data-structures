n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 
이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.


이 문제는 이진 트리의 트래버설 순서를 이용하여 트리를 재구성하는 문제
주어진 인오더(in-order)와 포스트오더(post-order)를 통해 프리오더(pre-order)를 구하는 문제

이진 트리의 트래버설 순서에 대한 기본 지식:

프리오더(pre-order): 루트 -> 왼쪽 서브트리 -> 오른쪽 서브트리
인오더(in-order): 왼쪽 서브트리 -> 루트 -> 오른쪽 서브트리
포스트오더(post-order): 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트
문제를 해결하기 위해서 다음과 같은 단계로 접근할 수 있습니다:

포스트오더의 마지막 요소는 항상 루트 노드입니다.
인오더에서 해당 루트 노드를 기준으로 왼쪽 서브트리와 오른쪽 서브트리로 분할할 수 있습니다.
재귀적으로 서브트리를 처리하여 프리오더를 출력합니다.


import sys
sys.setrecursionlimit(200000)
input = sys.stdin.read

def build_preorder(in_start, in_end, post_start, post_end):
    if in_start > in_end or post_start > post_end:
        return
    
    root = postorder[post_end]
    preorder.append(root)
    
    root_index = inorder_index[root]
    
    left_size = root_index - in_start
    
    build_preorder(in_start, root_index - 1, post_start, post_start + left_size - 1)
    build_preorder(root_index + 1, in_end, post_start + left_size, post_end - 1)

n = int(input())
inorder = list(map(int, input().split()))
postorder = list(map(int, input().split()))

inorder_index = {value: idx for idx, value in enumerate(inorder)}

preorder = []
build_preorder(0, n - 1, 0, n - 1)

print(' '.join(map(str, preorder)))
