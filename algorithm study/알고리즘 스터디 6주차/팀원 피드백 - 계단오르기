6주차 계단오르기 

dp : 동적 프로그래밍 
재귀함수 많이 사용함

저장공간 하나 만들고 거기에 경우하나 저장한다.
이후 다른 조건 비교하면서 이게 빠르네? 느리네? 확인하는 것이다.


f(n)=f(n-1)+a
f(1) = k

N = int(input())
s = [0]301 #계단 수 최대 300개
for i in range(N):
    s[i] = int(input())

DP = [0]301 #  DP 리스트는 각 계단에 도착했을 때 얻을 수 있는 최대 점수를 저장한다.
DP[0] = s[0] #DP[0]은 첫 번째 계단의 점수로 초기화
DP[1] = s[0] + s[1] #DP[1]은 첫 번째 계단과 두 번째 계단을 모두 밟는 경우의 점수로 초기화
DP[2] = max(s[0] + s[2], s[1] + s[2])
#DP[2]는 두 번째 계단과 세 번째 계단을 모두 밟는 경우와 
#첫 번째 계단은 밟지 않고 두 번째, 세 번째 계단을 밟는 경우 중 더 큰 점수로 초기화

for i in range(3, N):
    DP[i] = max(DP[i-3] + s[i-1] + s[i], DP[i-2] + s[i])
#i번째 계단에 도착했을 때 얻을 수 있는 최대 점수를 계산합니다.
#이전 계단에서 i번째 계단까지 도달할 수 있는 경우의 수는 두 가지입니다.
#i-3번째 계단에서 한 번에 세 칸을 올라와서 i-1번째 계단과 i번째 계단을 밟는 경우
#i-2번째 계단에서 두 칸을 올라와서 i번째 계단을 밟는 경우
#이 두 가지 경우 중 어느 것이 더 큰 점수를 가질지를 판단하여 DP[i]에 저장합니다.

print(DP[N-1])
